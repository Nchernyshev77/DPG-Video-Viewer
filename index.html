<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DPG Video Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="referrer" content="no-referrer">
  <link rel="icon" href="data:,">
  <style>
    :root { color-scheme: dark light; }
    html, body { margin:0; padding:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu; }
    #viewer { position:fixed; inset:0; background:#000; overflow:hidden; }
    #toolbar { position:fixed; top:8px; left:8px; right:8px; display:flex; gap:.5rem; align-items:center; z-index:10 }
    .group { display:flex; gap:.25rem; align-items:center; }
    .btn { appearance:none; border:1px solid #8883; border-radius:8px; background:#2228; color:#fff; padding:.45rem .7rem; cursor:pointer; }
    .btn:disabled{ opacity:.5; cursor:not-allowed }
    #plistPanel{ position:fixed; bottom:0; left:0; right:0; background:#111a; color:#eee; padding:.5rem; display:flex; gap:.5rem; align-items:center; z-index:10 }
    #introBackdrop{ position:fixed; inset:0; background:#000d; display:none; align-items:center; justify-content:center; z-index:9 }
    #introBackdrop.show{ display:flex }
    #status{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); padding:1rem 1.25rem; background:#111c; border:1px solid #555; border-radius:12px; color:#eee; display:none; z-index:11; min-width:260px; text-align:center }
    #status.show{ display:block }
    #status progress{ width:100% }
    #hint { opacity:.75; }
  </style>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>
<body>
  <div id="viewer"></div>

  <div id="toolbar">
    <div class="group">
      <label class="btn">
        Open
        <input id="file" type="file" accept="video/*" multiple style="display:none">
      </label>
      <button id="uploadAndLinkBtn" class="btn" title="Загрузить в Drive и скопировать ссылки">Upload and Link</button>
    </div>
  </div>

  <div id="plistPanel">
    <span id="hint">Drop video files here or click “Open”.</span>
  </div>

  <div id="introBackdrop"></div>
  <div id="status">
    <div id="statusText" style="margin-bottom:.5rem">Downloading…</div>
    <progress id="progress" value="0" max="1"></progress>
  </div>

  <script type="module">
    // ---------- Minimal player glue (replace with your WebGL/VR as needed) ----------
    const I = id => document.getElementById(id);
    const status = I('status'), progress = I('progress'), statusText = I('statusText'), introBackdrop = I('introBackdrop');

    let videoEl = null;
    function ensureVideo(){
      if (!videoEl){
        videoEl = document.createElement('video');
        videoEl.controls = true;
        videoEl.playsInline = true;
        videoEl.style.position='absolute';
        videoEl.style.inset='0';
        videoEl.style.width='100%';
        videoEl.style.height='100%';
        videoEl.style.objectFit='contain';
        I('viewer').appendChild(videoEl);
      }
      return videoEl;
    }
    function loadURL(url, label='remote', {autoplay=false}={}){
      const v = ensureVideo();
      v.src = url;
      if (autoplay) v.play().catch(()=>{});
    }

    // Playlist (very simple)
    let playlist = [];
    let currentIndex = -1;

    I('file').addEventListener('change', (e)=>{
      addFiles(e.target.files);
      e.target.value = '';
    });

    // Drag & Drop
    document.addEventListener('dragover', e=>{ e.preventDefault(); });
    document.addEventListener('drop', e=>{
      e.preventDefault();
      if (e.dataTransfer && e.dataTransfer.files) addFiles(e.dataTransfer.files);
    });

    function addFiles(fileList){
      const files = Array.from(fileList || []).filter(f => /^video\\//.test(f.type) || /\\.(mp4|webm|mov|mkv|m4v)$/i.test(f.name));
      if (!files.length) return;
      playlist = files.map((f, i)=>({ file:f, name:f.name }));
      currentIndex = 0;
      const url = URL.createObjectURL(playlist[0].file);
      loadURL(url, playlist[0].name, {autoplay:true});
      I('hint').textContent = playlist.map(p=>p.name).join(' • ');
    }

    // ---------- Google Drive + IndexedDB cache (one-button flow, multi-domain) ----------
    // CONFIG — заполните ваши значения:
    const DRIVE_GOOGLE_CLIENT_ID = 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com'; // ОБЯЗАТЕЛЬНО
    const DRIVE_FOLDER_ID        = 'YOUR_DRIVE_FOLDER_ID';                             // ОБЯЗАТЕЛЬНО
    const SHARE_SCOPE   = 'anyone';                 // 'anyone' | 'domain'
    const DRIVE_DOMAINS = ['your-domain.tld'];      // если SHARE_SCOPE='domain' — список доменов

    // Кэш
    const CACHE_TTL_MS = 30 * 24 * 60 * 60 * 1000;  // 30 дней
    const CACHE_MAX_FRACTION = 0.5;                 // до 50% квоты сайта

    // OAuth (по требованию)
    let driveAccessToken = null;
    let driveTokenClient = null;
    function initDriveAuth(){
      if (!window.google || !google.accounts || !google.accounts.oauth2) return;
      driveTokenClient = google.accounts.oauth2.initTokenClient({
        client_id: DRIVE_GOOGLE_CLIENT_ID,
        scope: 'https://www.googleapis.com/auth/drive',
        callback: (resp)=>{ if (resp && resp.access_token) driveAccessToken = resp.access_token; }
      });
    }
    window.addEventListener('load', initDriveAuth);
    function ensureDriveToken(){
      return new Promise((resolve, reject)=>{
        if (driveAccessToken) return resolve(driveAccessToken);
        if (!driveTokenClient) initDriveAuth();
        driveTokenClient.callback = (resp)=>{
          if (resp && resp.access_token){ driveAccessToken = resp.access_token; resolve(driveAccessToken); }
          else reject(new Error('Нет access_token'));
        };
        driveTokenClient.requestAccessToken({ prompt:'consent' });
      });
    }

    // IndexedDB
    const DB_NAME = 'vr_video_cache';
    const DB_STORE = 'files';
    let dbPromise = null;
    function idbOpen(){
      if (dbPromise) return dbPromise;
      dbPromise = new Promise((resolve,reject)=>{
        const r = indexedDB.open(DB_NAME, 1);
        r.onupgradeneeded = ()=>{
          const db = r.result;
          if (!db.objectStoreNames.contains(DB_STORE)){
            const s = db.createObjectStore(DB_STORE, { keyPath:'key' });
            s.createIndex('lastUsedAt','lastUsedAt');
            s.createIndex('createdAt','createdAt');
            s.createIndex('expiresAt','expiresAt');
            s.createIndex('size','size');
          }
        };
        r.onsuccess = ()=> resolve(r.result);
        r.onerror = ()=> reject(r.error);
      });
      return dbPromise;
    }
    function idbGet(key){
      return idbOpen().then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readonly');
        const req = tx.objectStore(DB_STORE).get(key);
        req.onsuccess = ()=> res(req.result || null);
        req.onerror = ()=> rej(req.error);
      }));
    }
    function idbPut(rec){
      return idbOpen().then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        tx.objectStore(DB_STORE).put(rec);
        tx.oncomplete = ()=> res(true);
        tx.onerror = ()=> rej(tx.error);
      }));
    }
    function idbDelete(key){
      return idbOpen().then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        tx.objectStore(DB_STORE).delete(key);
        tx.oncomplete = ()=> res(true);
        tx.onerror = ()=> rej(tx.error);
      }));
    }
    function idbAll(){
      return idbOpen().then(db=> new Promise((res,rej)=>{
        const tx = db.transaction(DB_STORE,'readonly');
        const req = tx.objectStore(DB_STORE).getAll();
        req.onsuccess = ()=> res(req.result || []);
        req.onerror = ()=> rej(req.error);
      }));
    }
    async function storageEstimate(){
      if (navigator.storage && navigator.storage.estimate){
        try { return await navigator.storage.estimate(); } catch(e){}
      }
      return { usage:0, quota: 1024*1024*1024 };
    }
    async function autoEvictIfNeeded(addBytes=0){
      const now = Date.now();
      const recs = await idbAll();
      for (const r of recs){ if (r.expiresAt && r.expiresAt <= now) await idbDelete(r.key); }
      const {usage=0, quota=1} = await storageEstimate();
      const limit = quota * CACHE_MAX_FRACTION;
      if (usage + addBytes <= limit) return;
      const alive = (await idbAll()).sort((a,b)=> (a.lastUsedAt||0)-(b.lastUsedAt||0));
      let cur = usage;
      for (const r of alive){
        if (cur + addBytes <= limit) break;
        await idbDelete(r.key);
        cur -= (r.size||0);
      }
    }
    async function cacheGetBlob(fileId){
      const rec = await idbGet('drive:'+fileId);
      if (!rec) return null;
      if (rec.expiresAt && rec.expiresAt <= Date.now()){ await idbDelete(rec.key); return null; }
      const blob = new Blob(rec.chunks, { type: rec.mime || 'application/octet-stream' });
      rec.lastUsedAt = Date.now();
      try { await idbPut(rec); } catch(e){}
      return blob;
    }
    async function cachePutBlob(fileId, blob, mime){
      const buf = await blob.arrayBuffer();
      const chunk = new Uint8Array(buf);
      await autoEvictIfNeeded(chunk.byteLength);
      const rec = {
        key: 'drive:'+fileId,
        fileId, mime: mime || blob.type || 'application/octet-stream',
        size: chunk.byteLength,
        createdAt: Date.now(),
        lastUsedAt: Date.now(),
        expiresAt: Date.now() + CACHE_TTL_MS,
        chunks: [chunk]
      };
      await idbPut(rec);
    }

    // Upload + share (one button)
    async function uploadCurrentToDriveAndCopyLink(){
      try{
        const cur = (playlist && playlist[0] && playlist[0].file) ? playlist[0].file : null;
        if (!cur) { alert('Сначала добавьте локальный видеофайл (Open или перетащите).'); return; }

        await ensureDriveToken();

        const metadata = { name: cur.name, parents: [DRIVE_FOLDER_ID] };
        const boundary = '-------314159265358979323846';
        const delimiter = '\\r\\n--' + boundary + '\\r\\n';
        const closeDelim = '\\r\\n--' + boundary + '--';
        const metaPart = 'Content-Type: application/json; charset=UTF-8\\r\\n\\r\\n' + JSON.stringify(metadata);
        const fileBuf = new Uint8Array(await cur.arrayBuffer());
        const filePart = 'Content-Type: ' + (cur.type || 'application/octet-stream') + '\\r\\n\\r\\n';
        const body = new Blob([ delimiter, metaPart, delimiter, filePart, fileBuf, closeDelim ], { type: 'multipart/related; boundary=' + boundary });

        const createRes = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&supportsAllDrives=true', {
          method: 'POST',
          headers: { Authorization: 'Bearer ' + driveAccessToken },
          body
        });
        const created = await createRes.json();
        if (!createRes.ok) throw new Error(created && (created.error && created.error.message || JSON.stringify(created)));
        const fileId = created.id;

        if (SHARE_SCOPE === 'anyone'){
          await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/permissions?supportsAllDrives=true`, {
            method: 'POST',
            headers: { Authorization: 'Bearer ' + driveAccessToken, 'Content-Type': 'application/json' },
            body: JSON.stringify({ type: 'anyone', role: 'reader' })
          });
        } else if (SHARE_SCOPE === 'domain' && Array.isArray(DRIVE_DOMAINS)){
          for (const dom of DRIVE_DOMAINS){
            if (!dom || typeof dom !== 'string') continue;
            await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/permissions?supportsAllDrives=true`, {
              method: 'POST',
              headers: { Authorization: 'Bearer ' + driveAccessToken, 'Content-Type': 'application/json' },
              body: JSON.stringify({ type: 'domain', role: 'reader', domain: dom, allowFileDiscovery: false })
            });
          }
        }

        const metaRes = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?fields=id,name,webViewLink&supportsAllDrives=true`, {
          headers: { Authorization: 'Bearer ' + driveAccessToken }
        });
        const info = await metaRes.json();

        const appLink = location.origin + location.pathname + '?id=' + encodeURIComponent(fileId);
        const text = `Drive: ${info.webViewLink}\nPlay in app: ${appLink}`;
        await navigator.clipboard.writeText(text);
        alert('Ссылки скопированы:\\n' + text);
      }catch(e){
        alert('Upload failed: ' + (e && e.message ? e.message : e));
      }
    }
    document.getElementById('uploadAndLinkBtn').addEventListener('click', uploadCurrentToDriveAndCopyLink);

    // Load by ?id -> cache -> play
    async function fetchDriveFileToBlob(fileId){
      await ensureDriveToken();
      const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?alt=media&supportsAllDrives=true`;
      const r = await fetch(url, { headers: { Authorization: 'Bearer ' + driveAccessToken } });
      if (!r.ok) throw new Error('Drive fetch failed: ' + r.status);
      const contentType = r.headers.get('Content-Type') || 'application/octet-stream';
      const reader = r.body.getReader();
      const chunks = [];
      let received = 0;
      try { status.classList.add('show'); introBackdrop.classList.add('show'); progress.value = 0; progress.max = 1; statusText.textContent = 'Downloading from Drive…'; } catch(e){}
      const total = Number(r.headers.get('Content-Length')||0);
      while (true){
        const {done, value} = await reader.read();
        if (done) break;
        chunks.push(value);
        received += value.byteLength;
        if (total > 0){ try { progress.value = received/total; } catch(e){} }
      }
      try { status.classList.remove('show'); introBackdrop.classList.remove('show'); } catch(e){}
      return new Blob(chunks, { type: contentType });
    }
    async function loadFromCacheOrDrive(fileId){
      let blob = await cacheGetBlob(fileId);
      if (!blob){
        blob = await fetchDriveFileToBlob(fileId);
        try { await cachePutBlob(fileId, blob, blob.type); } catch(e){}
      }
      const url = URL.createObjectURL(blob);
      loadURL(url, 'driveCached:'+fileId, {autoplay:false});
    }
    (async function(){
      const id = new URL(location.href).searchParams.get('id');
      if (id){ try { await loadFromCacheOrDrive(id); } catch(e){ alert('Open by id failed: ' + e.message); } }
    })();
  </script>
</body>
</html>
