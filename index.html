<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DPG Video Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="referrer" content="no-referrer">
  <link rel="icon" href="data:,">
  <style>
    :root { color-scheme: dark light; }
    html, body { margin:0; padding:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu; }
    #viewer { position:fixed; inset:0; background:#000; overflow:hidden; }

    /* toolbar from old UI (minimal stub; keep your original toolbar styles if present) */
    #toolbar { position:fixed; top:8px; left:8px; right:8px; display:flex; gap:.5rem; align-items:center; z-index:10 }
    .group { display:flex; gap:.25rem; align-items:center; }
    .btn { appearance:none; border:1px solid #8883; border-radius:8px; background:#2228; color:#fff; padding:.45rem .7rem; cursor:pointer; }
    .btn:disabled{ opacity:.5; cursor:not-allowed }

    #plistPanel{ position:fixed; bottom:0; left:0; right:0; background:#111a; color:#eee; padding:.5rem; display:flex; gap:.5rem; align-items:center; z-index:10 }
    #introBackdrop{ position:fixed; inset:0; background:#000d; display:none; align-items:center; justify-content:center; z-index:9 }
    #introBackdrop.show{ display:flex }
    #status{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); padding:1rem 1.25rem; background:#111c; border:1px solid #555; border-radius:12px; color:#eee; display:none; z-index:11; min-width:260px; text-align:center }
    #status.show{ display:block }
    #status progress{ width:100% }
    #hint { opacity:.75; }

    /* In-app modal for link (no browser alert) */
    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:20; }
    .modal.show{ display:flex; }
    .modal .backdrop{ position:absolute; inset:0; background:#0008; backdrop-filter: blur(2px); }
    .modal .card{ position:relative; background:#1b1b1b; color:#eee; border:1px solid #444; border-radius:12px; padding:16px; width:min(680px, 92vw); box-shadow:0 10px 30px #000a; }
    .modal h3{ margin:0 0 10px 0; font-weight:600; font-size:16px; }
    .row{ display:flex; gap:.5rem; align-items:center; }
    .row input{ flex:1; background:#0f0f0f; color:#fff; border:1px solid #3a3a3a; border-radius:8px; padding:.6rem .7rem; font-size:14px; }
    .iconbtn{ display:inline-flex; align-items:center; justify-content:center; border:1px solid #3a3a3a; background:#222; color:#fff; border-radius:8px; padding:.55rem .7rem; cursor:pointer; }
    .iconbtn:active{ transform:translateY(1px); }
    .right{ display:flex; gap:.5rem; justify-content:flex-end; margin-top:10px; }
    .muted{ opacity:.8; font-size:12px; margin-top:6px; }

    /* token gate button for ?id flow */
    #gate { position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:12; }
    #gate.show{ display:flex; }
    #gate .card{ background:#111c; color:#eee; border:1px solid #555; border-radius:12px; padding:16px 18px; box-shadow: 0 6px 20px #000a; }
  </style>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>
<body>
  <div id="viewer"></div>

  <div id="toolbar">
    <div class="group">
      <label class="btn">
        Open
        <input id="file" type="file" accept="video/*" multiple style="display:none">
      </label>
      <button id="uploadAndLinkBtn" class="btn" title="–ó–∞–≥—Ä—É–∑–∏—Ç—å –≤ Drive –∏ –ø–æ–∫–∞–∑–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ">Upload and Link</button>
    </div>
  </div>

  <div id="plistPanel">
    <span id="hint">Drop video files here or click ‚ÄúOpen‚Äù.</span>
  </div>

  <div id="introBackdrop"></div>
  <div id="status">
    <div id="statusText" style="margin-bottom:.5rem">Downloading‚Ä¶</div>
    <progress id="progress" value="0" max="1"></progress>
  </div>

  <!-- Token gate for ?id -->
  <div id="gate">
    <div class="card">
      <div style="margin-bottom:8px">–î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤–∏–¥–µ–æ –Ω—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∫ Google Drive.</div>
      <button id="gateBtn" class="btn">–û—Ç–∫—Ä—ã—Ç—å –≤–∏–¥–µ–æ</button>
    </div>
  </div>

  <!-- In-app modal for app link -->
  <div id="linkModal" class="modal" aria-hidden="true">
    <div class="backdrop"></div>
    <div class="card">
      <h3>–°—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏</h3>
      <div class="row">
        <input id="appLinkInput" readonly value="">
        <button id="copyBtn" class="iconbtn" title="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É">üìã</button>
      </div>
      <div class="right">
        <button id="closeLink" class="btn">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
      <div class="muted">–°—Å—ã–ª–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞ –≤ –±—É—Ñ–µ—Ä. –ö–Ω–æ–ø–∫–∞ üìã ‚Äî –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ.</div>
    </div>
  </div>

  <script type="module">
    // ---------- Minimal player glue (–∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à WebGL/VR –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏) ----------
    const I = id => document.getElementById(id);
    const status = I('status'), progress = I('progress'), statusText = I('statusText'), introBackdrop = I('introBackdrop');

    let videoEl = null;
    function ensureVideo(){
      if (!videoEl){
        videoEl = document.createElement('video');
        videoEl.controls = true;
        videoEl.playsInline = true;
        videoEl.style.position='absolute';
        videoEl.style.inset='0';
        videoEl.style.width='100%';
        videoEl.style.height='100%';
        videoEl.style.objectFit='contain';
        I('viewer').appendChild(videoEl);
      }
      return videoEl;
    }
    function loadURL(url, label='remote', {autoplay=false}={}){
      const v = ensureVideo();
      v.src = url;
      if (autoplay) v.play().catch(()=>{});
    }

    // Playlist
    let playlist = [];
    let currentIndex = -1;

    I('file').addEventListener('change', (e)=>{
      addFiles(e.target.files);
      e.target.value = '';
    });
    document.addEventListener('dragover', e=>{ e.preventDefault(); });
    document.addEventListener('drop', e=>{
      e.preventDefault();
      if (e.dataTransfer && e.dataTransfer.files) addFiles(e.dataTransfer.files);
    });

    function addFiles(fileList){
      const files = Array.from(fileList || []).filter(f => /^video\\//.test(f.type) || /\\.(mp4|webm|mov|mkv|m4v)$/i.test(f.name));
      if (!files.length) return;
      playlist = files.map(f => ({ file:f, name:f.name }));
      currentIndex = 0;
      const url = URL.createObjectURL(playlist[0].file);
      loadURL(url, playlist[0].name, {autoplay:true});
      I('hint').textContent = playlist.map(p=>p.name).join(' ‚Ä¢ ');
      // remember last selected
      window.__lastSelectedFile = playlist[0].file;
    }

    // ---------- Google Drive + IndexedDB cache (one-button flow) ----------
    // CONFIG ‚Äî —Å –≤–∞—à–∏–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏:
    const DRIVE_GOOGLE_CLIENT_ID = '1053048724849-jaoe9s17j4okh8esuf7ffd2lqijluat8.apps.googleusercontent.com';
    const DRIVE_FOLDER_ID        = '1zkzCbXzRoUZP7Ps1ozV3U3Mkh7GOqR1t';
    const SHARE_SCOPE   = 'domain';
    const DRIVE_DOMAINS = ['dpg.email','aktd.email'];

    // –ö—ç—à
    const CACHE_TTL_MS = 30 * 24 * 60 * 60 * 1000;
    const CACHE_MAX_FRACTION = 0.5;

    // OAuth helpers (—Å –ø–æ–ø—ã—Ç–∫–æ–π ¬´—Ç–∏—Ö–æ¬ª, —á—Ç–æ–±—ã –æ–∫–Ω–æ —Å–æ–≥–ª–∞—Å–∏—è –ø–æ–∫–∞–∑—ã–≤–∞–ª–æ—Å—å –æ–¥–∏–Ω —Ä–∞–∑)
    let driveAccessToken = null;
    let driveTokenClient = null;
    function initDriveAuth(){
      if (!window.google || !google.accounts || !google.accounts.oauth2) return;
      driveTokenClient = google.accounts.oauth2.initTokenClient({
        client_id: DRIVE_GOOGLE_CLIENT_ID,
        scope: 'https://www.googleapis.com/auth/drive',
        callback: (resp)=>{
          if (resp && resp.access_token){ driveAccessToken = resp.access_token; localStorage.setItem('drive_oauth_granted','1'); }
        }
      });
    }
    window.addEventListener('load', initDriveAuth);

    function requestToken(options={}){
      return new Promise((resolve, reject)=>{
        if (!driveTokenClient){ initDriveAuth(); }
        if (!driveTokenClient){ reject(new Error('oauth_lib_not_loaded')); return; }

        driveTokenClient.callback = (resp)=>{
          if (resp && resp.access_token){ driveAccessToken = resp.access_token; localStorage.setItem('drive_oauth_granted','1'); resolve(driveAccessToken); }
          else { reject(new Error((resp && (resp.error_description || resp.error)) || 'no_access_token')); }
        };
        driveTokenClient.requestAccessToken(options);
      });
    }

    async function ensureDriveToken({interactive=false}={}){
      if (driveAccessToken) return driveAccessToken;

      // –µ—Å–ª–∏ —É–∂–µ –¥–∞–≤–∞–ª–∏ —Å–æ–≥–ª–∞—Å–∏–µ ‚Äî –ø—Ä–æ–±—É–µ–º —Ç–∏—Ö–æ
      if (localStorage.getItem('drive_oauth_granted') === '1'){
        try {
          await requestToken({ prompt: '' });
          if (driveAccessToken) return driveAccessToken;
        } catch(_) { /* —Ç–∏—Ö–∞—è –ø–æ–ø—ã—Ç–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å ‚Äî –Ω–∏–∂–µ —Ä–µ—à–∏–º, –º–æ–∂–Ω–æ –ª–∏ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ */ }
      }
      if (interactive){
        await requestToken({ prompt: 'consent' });
        return driveAccessToken;
      }
      // –±–µ–∑ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–∞ ‚Äî —Å–æ–æ–±—â–∏–º, —á—Ç–æ –Ω—É–∂–µ–Ω –∫–ª–∏–∫
      throw new Error('needs_user_gesture');
    }

    // IndexedDB
    const DB_NAME='vr_video_cache'; const DB_STORE='files'; let dbPromise=null;
    function idbOpen(){
      if (dbPromise) return dbPromise;
      dbPromise = new Promise((resolve,reject)=>{
        const r = indexedDB.open(DB_NAME,1);
        r.onupgradeneeded = ()=>{
          const db = r.result;
          if (!db.objectStoreNames.contains(DB_STORE)){
            const s = db.createObjectStore(DB_STORE, { keyPath:'key' });
            s.createIndex('lastUsedAt','lastUsedAt'); s.createIndex('createdAt','createdAt');
            s.createIndex('expiresAt','expiresAt'); s.createIndex('size','size');
          }
        };
        r.onsuccess = ()=> resolve(r.result); r.onerror = ()=> reject(r.error);
      });
      return dbPromise;
    }
    function idbGet(key){ return idbOpen().then(db=> new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readonly'); const req=tx.objectStore(DB_STORE).get(key); req.onsuccess=()=>res(req.result||null); req.onerror=()=>rej(req.error); })); }
    function idbPut(rec){ return idbOpen().then(db=> new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readwrite'); tx.objectStore(DB_STORE).put(rec); tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error); })); }
    function idbDelete(key){ return idbOpen().then(db=> new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readwrite'); tx.objectStore(DB_STORE).delete(key); tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error); })); }
    function idbAll(){ return idbOpen().then(db=> new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readonly'); const req=tx.objectStore(DB_STORE).getAll(); req.onsuccess=()=>res(req.result||[]); req.onerror=()=>rej(req.error); })); }
    async function storageEstimate(){ if (navigator.storage && navigator.storage.estimate){ try{return await navigator.storage.estimate();}catch(e){} } return {usage:0, quota: 1024*1024*1024}; }
    async function autoEvictIfNeeded(addBytes=0){
      const now=Date.now(); const recs=await idbAll();
      for (const r of recs){ if (r.expiresAt && r.expiresAt<=now) await idbDelete(r.key); }
      const {usage=0, quota=1}=await storageEstimate(); const limit=quota*CACHE_MAX_FRACTION;
      if (usage+addBytes<=limit) return;
      const alive=(await idbAll()).sort((a,b)=> (a.lastUsedAt||0)-(b.lastUsedAt||0));
      let cur=usage; for (const r of alive){ if (cur+addBytes<=limit) break; await idbDelete(r.key); cur-= (r.size||0); }
    }
    async function cacheGetBlob(fileId){
      const rec=await idbGet('drive:'+fileId); if (!rec) return null;
      if (rec.expiresAt && rec.expiresAt<=Date.now()){ await idbDelete(rec.key); return null; }
      const blob = new Blob(rec.chunks, { type: rec.mime||'application/octet-stream' });
      rec.lastUsedAt = Date.now(); try{ await idbPut(rec);}catch(e){}
      return blob;
    }
    async function cachePutBlob(fileId, blob, mime){
      const buf = await blob.arrayBuffer(); const chunk=new Uint8Array(buf);
      await autoEvictIfNeeded(chunk.byteLength);
      const rec = { key:'drive:'+fileId, fileId, mime: mime||blob.type||'application/octet-stream', size:chunk.byteLength, createdAt:Date.now(), lastUsedAt:Date.now(), expiresAt:Date.now()+CACHE_TTL_MS, chunks:[chunk] };
      await idbPut(rec);
    }

    // Resumable upload (–Ω–∞–¥—ë–∂–Ω–æ –¥–ª—è –∫—Ä—É–ø–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤)
    async function createResumableSession(f){
      const init = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=resumable&supportsAllDrives=true', {
        method: 'POST',
        headers: {
          Authorization: 'Bearer ' + driveAccessToken,
          'Content-Type': 'application/json; charset=UTF-8',
          'X-Upload-Content-Type': (f.type || 'application/octet-stream'),
          'X-Upload-Content-Length': String(f.size)
        },
        body: JSON.stringify({ name: (f.name||'video'), parents: [DRIVE_FOLDER_ID] })
      });
      if (!init.ok) throw new Error('init_fail: '+init.status);
      const sessionUrl = init.headers.get('Location');
      if (!sessionUrl) throw new Error('no_upload_session');
      return sessionUrl;
    }
    async function uploadChunks(sessionUrl, f, onProgress){
      const chunkSize = 8 * 1024 * 1024;
      let offset = 0;
      while (offset < f.size){
        const end = Math.min(offset + chunkSize, f.size);
        const chunk = f.slice(offset, end);
        const res = await fetch(sessionUrl, {
          method: 'PUT',
          headers: {
            'Content-Type': (f.type || 'application/octet-stream'),
            'Content-Length': String(chunk.size),
            'Content-Range': `bytes ${offset}-${end-1}/${f.size}`
          },
          body: chunk
        });
        if (res.status === 308){
          const rng = res.headers.get('Range');
          if (rng){
            const m = rng.match(/(\d+)-(\d+)$/);
            if (m) offset = parseInt(m[2],10) + 1; else offset = end;
          } else offset = end;
          if (onProgress) onProgress(offset, f.size);
          continue;
        }
        if (!res.ok) throw new Error('chunk_fail: '+res.status);
        const data = await res.json();
        return data;
      }
      throw new Error('unexpected_end');
    }

    // UI helpers for link modal
    function showLinkModal(appLink){
      const modal = I('linkModal');
      const input = I('appLinkInput');
      const copy  = I('copyBtn');
      const close = I('closeLink');
      input.value = appLink;
      modal.classList.add('show');
      modal.setAttribute('aria-hidden', 'false');
      // auto copy
      navigator.clipboard.writeText(appLink).catch(()=>{});
      copy.onclick = ()=> navigator.clipboard.writeText(appLink);
      close.onclick = ()=> { modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); };
      modal.querySelector('.backdrop').onclick = close.onclick;
    }

    // Upload button
    document.getElementById('uploadAndLinkBtn').addEventListener('click', async (ev)=>{
      ev.preventDefault(); ev.stopImmediatePropagation();
      try{
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–∞–π–ª
        let f = null;
        if (typeof currentFile !== 'undefined' && currentFile) f = currentFile;
        if (!f && playlist && playlist.length) f = (playlist[currentIndex]?.file) || (playlist[0]?.file);
        if (!f && window.__lastSelectedFile) f = window.__lastSelectedFile;
        if (!f){
          // –ø–æ–ø—Ä–æ–±—É–µ–º –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ <video>
          const v = document.querySelector('video'); const src = v && (v.currentSrc || v.src);
          if (src && /^blob:/i.test(src)){ const b = await fetch(src).then(r=>r.blob()); try{ f = new File([b],'video_from_player',{type:b.type}); }catch(_){ f=b; } }
        }
        if (!f){ alert('–°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å—Ç–µ –ª–æ–∫–∞–ª—å–Ω—ã–π –≤–∏–¥–µ–æ—Ñ–∞–π–ª (Open –∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ).'); return; }

        // –¢–æ–∫–µ–Ω (–∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ ‚Äî –æ–¥–∏–Ω —Ä–∞–∑, –¥–∞–ª–µ–µ –±—É–¥–µ—Ç —Ç–∏—Ö–æ)
        await ensureDriveToken({interactive:true});

        // –ü—Ä–æ–≥—Ä–µ—Å—Å
        try{ status.classList.add('show'); introBackdrop.classList.add('show'); if(progress){progress.value=0;progress.max=1;} if(statusText) statusText.textContent='Uploading to Drive‚Ä¶'; }catch(e){}

        const session = await createResumableSession(f);
        const info = await uploadChunks(session, f, (done,total)=>{ try{ if(progress){ progress.value = total ? (done/total) : 0; } }catch(e){} });

        try{ status.classList.remove('show'); introBackdrop.classList.remove('show'); }catch(e){}
        const fileId = info && info.id; if (!fileId) throw new Error('no_file_id');

        // –ü—Ä–∞–≤–∞ –¥–ª—è –¥–æ–º–µ–Ω–æ–≤
        for (const dom of DRIVE_DOMAINS){
          await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/permissions?supportsAllDrives=true`, {
            method:'POST', headers:{ Authorization:'Bearer '+driveAccessToken, 'Content-Type':'application/json' },
            body: JSON.stringify({ type:'domain', role:'reader', domain: dom, allowFileDiscovery:false })
          });
        }

        // –¢–æ–ª—å–∫–æ —Å—Å—ã–ª–∫–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        const appLink = location.origin + location.pathname + '?id=' + encodeURIComponent(fileId);
        showLinkModal(appLink);
      }catch(e){
        const msg = (e && e.message) || String(e);
        if (msg.includes('popup_blocked_or_denied')){
          alert('–û–∫–Ω–æ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ Google –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –∏–ª–∏ –∑–∞–∫—Ä—ã—Ç–æ. –†–∞–∑—Ä–µ—à–∏—Ç–µ –≤—Å–ø–ª—ã–≤–∞—é—â–∏–µ –æ–∫–Ω–∞ –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ.');
        } else if (msg.includes('oauth_lib_not_loaded')){
          alert('–ù–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ Google OAuth (accounts.google.com). –ü—Ä–æ–≤–µ—Ä—å—Ç–µ Authorized JavaScript origins.');
        } else {
          alert('Upload failed: ' + msg);
        }
      }
    }, true);

    // –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ ?id ‚Äî —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º ¬´—Ç–∏—Ö–æ¬ª, –µ—Å–ª–∏ –Ω–µ–ª—å–∑—è ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É gate
    async function fetchDriveFileToBlob(fileId){
      const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?alt=media&supportsAllDrives=true`;
      const r = await fetch(url, { headers: { Authorization:'Bearer '+driveAccessToken } });
      if (!r.ok) throw new Error('Drive fetch failed: ' + r.status);
      const type = r.headers.get('Content-Type') || 'application/octet-stream';
      const reader = r.body.getReader();
      const chunks=[]; let received=0;
      try{ status.classList.add('show'); introBackdrop.classList.add('show'); if(progress){progress.value=0;} if(statusText) statusText.textContent='Downloading from Drive‚Ä¶'; }catch(e){}
      const total = Number(r.headers.get('Content-Length')||0);
      while(true){
        const {done,value}=await reader.read(); if(done) break;
        chunks.push(value); received+=value.byteLength;
        if (total>0){ try{ progress.value = received/total; }catch(e){} }
      }
      try{ status.classList.remove('show'); introBackdrop.classList.remove('show'); }catch(e){}
      return new Blob(chunks, { type });
    }
    async function loadFromCacheOrDrive(fileId){
      let blob = await cacheGetBlob(fileId);
      if (!blob){
        blob = await fetchDriveFileToBlob(fileId);
        try{ await cachePutBlob(fileId, blob, blob.type); }catch(_){}
      }
      const url = URL.createObjectURL(blob);
      loadURL(url, 'drive:'+fileId, {autoplay:false});
    }

    (async function(){
      const id = new URL(location.href).searchParams.get('id');
      if (!id) return;
      try{
        await ensureDriveToken(); // —Ç–∏—Ö–æ, –µ—Å–ª–∏ —É–∂–µ –¥–∞–≤–∞–ª–∏
        if (!driveAccessToken) throw new Error('needs_user_gesture');
        await loadFromCacheOrDrive(id);
      }catch(e){
        // –ø–æ–∫–∞–∂–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–∞
        const g = I('gate'); const gb = I('gateBtn');
        g.classList.add('show');
        gb.onclick = async ()=>{
          try{
            await ensureDriveToken({interactive:true});
            g.classList.remove('show');
            await loadFromCacheOrDrive(id);
          }catch(err){
            alert((err && err.message) || String(err));
          }
        };
      }
    })();
  </script>
</body>
</html>
